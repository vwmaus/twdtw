% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/twdtw.R
\name{twdtw}
\alias{twdtw}
\alias{twdtw.data.frame}
\alias{twdtw.matrix}
\title{Calculate Time-Weighted Dynamic Time Warping (TWDTW) distance}
\usage{
twdtw(x, y, ...)

\method{twdtw}{data.frame}(
  x,
  y,
  time_weight_par = NULL,
  time_weight_fun = NULL,
  time_cycle_length = NULL,
  time_cycle_scale = NULL,
  index_column_name = "time",
  dtw_step_matrix = symmetric1,
  max_elapsed = Inf,
  return_distance = TRUE,
  return_all_matches = FALSE,
  version = "f90",
  ...
)

\method{twdtw}{matrix}(
  x,
  y,
  time_weight_par = NULL,
  time_weight_fun = NULL,
  time_cycle_length = NULL,
  time_cycle_scale = NULL,
  index_column_position = 1,
  dtw_step_matrix = symmetric1,
  max_elapsed = Inf,
  return_distance = TRUE,
  return_all_matches = FALSE,
  version = "f90",
  ...
)
}
\arguments{
\item{x}{A data.frame or matrix representing the first time series.}

\item{y}{A data.frame or matrix representing the second time series.}

\item{...}{Additional parameters to pass to the time weighting function.}

\item{time_weight_par}{(optional) A numeric vector of parameters to be used with the time weighting function.}

\item{time_weight_fun}{(optional) A user-defined function for time weighting.}

\item{time_cycle_length}{Required for data.frame inputs. A character string indicating the larger unit of time.
It must be one of "year", "month", "day", "hour", "minute". It can also receive a numeric value when time_cycle_scale is numeric.}

\item{time_cycle_scale}{Required for data.frame inputs. A character string specifying the time cycle scale or an integer value.}

\item{index_column_name}{(optional) The column name of the time index for data.frame inputs. Defaults to "time".}

\item{dtw_step_matrix}{A matrix specifying the step pattern for the TWDTW algorithm. Defaults to symmetric1.}

\item{max_elapsed}{Numeric value constraining the TWDTW calculation to the lower band given by a maximum elapsed time. Defaults to Inf.}

\item{return_distance}{Logical indicating whether to return the TWDTW distance. Defaults to TRUE.}

\item{return_all_matches}{Logical indicating whether to find all matches within the TWDTW matrix. Defaults to FALSE.}

\item{version}{A string identifying the version of TWDTW implementation. Options are 'f90' for Fortran 90, 'f90goto' for Fortran 90 with goto statements, or 'cpp' for C++ version. Defaults to 'f90'.}

\item{index_column_position}{(optional) The column position of the time index for matrix inputs. Defaults to 1.}
}
\value{
If return_distance = TRUE, a numeric value representing the TWDTW distance between the two time series.
If return_all_matches = TRUE, a matrix of all matches within the TWDTW matrix.
}
\description{
This function calculates the Time-Weighted Dynamic Time Warping (TWDTW) distance between two time series.
}
\examples{

# Create a time series
n <- 23
t <- seq(0, pi, length.out = n)
d <- seq(as.Date('2020-09-01'), length.out = n, by = "15 day")

x <- data.frame(time = d,      v1 = sin(t)*2 + runif(n))

# shift time by 30 days
y <- data.frame(time = d + 30, v1 = sin(t)*2 + runif(n))

plot(x, type = "l", xlim = range(c(d, d + 5)))
lines(y, col = "red")

# Calculate TWDTW distance between x and y using logistic weight
twdtw(x, y,
      time_cycle_length = 'year',
      time_cycle_scale = 'day',
      time_weight_par = c(steepness = -0.1, midpoint = 50))

# Pass a generic time-weight fucntion
twdtw(x, y,
      time_cycle_length = 'year',
      time_cycle_scale = 'day',
      time_weight_par = c(steepness = -0.1, midpoint = 50),
      time_weight_fun = function(x,y,tw1,tw2) x + 1.0 / (1.0 + exp(tw1 * (y - tw2))))

# Test other version
twdtw(x, y,
      time_cycle_length = 'year',
      time_cycle_scale = 'day',
      time_weight_par = c(steepness = -0.1, midpoint = 50),
      version = 'f90goto')

twdtw(x, y,
      time_cycle_length = 'year',
      time_cycle_scale = 'day',
      time_weight_par = c(steepness = -0.1, midpoint = 50),
      version = 'cpp')

}
